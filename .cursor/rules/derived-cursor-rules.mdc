---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## Headers

This document defines the rules and guidelines for the AI coding assistant to follow while working on this project. It covers project structure, coding standards, workflow, and best practices. This file is a living document and will be updated as the project evolves.

## Project Description

The AI coding assistant is working on a multilingual code generation library named "Coder". This library aims to provide a flexible and extensible way to represent code in an Abstract Syntax Tree (AST) format, serialize and deserialize the AST to YAML, and generate code in various programming languages from the AST. The application project should be a TUI (Text User Interface) using Spectre.Console. One use case is to construct expressions, functions, objects via a node based visual editor, using this library as the authoring and storage provider for that frontend.

## TECH STACK

- .NET 7 or later
- YamlDotNet (for YAML serialization and deserialization)
- .NET 9 (identified during build process)
- Spectre.Console (for TUI)
- Spectre.Console.Cli (for command-line interface features)
- Microsoft.Extensions.DependencyInjection

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

- Implementation Plan: `docs/implementation-plan.md`
- Design Document: `docs/design.md`

## CODING STANDARDS

- Follow .NET coding conventions.
- Use meaningful names for variables, methods, and classes.
- Write clear and concise code with comments where necessary.
- Apply DRY (Don't Repeat Yourself) principle.
- Handle errors gracefully with appropriate exception handling.
- Write unit tests for all components.
- Use dependency injection to promote loose coupling.
- All files must include a copyright notice.
- Implement the `Clone()` method properly in AST node classes, ensuring derived classes `override` it. When cloning `Metadata`, clear the existing dictionary and copy the values from the original instead of assigning a new dictionary.
- Address code analysis warnings and errors identified during build processes (e.g., CS8852, IDE2003, CA1502, IDE0010, CA2227, CA1822, CS8604, CA1031, CA1062, IDE0060, CS1591, IDE0055).
    - Ensure that all method parameters are validated for null values, throwing `ArgumentNullException` when necessary.
    - Suppress CA1031 warnings only when catching generic exceptions at the top level of a `Main` method, using a pragma directive.
    - Ensure that all method parameters are validated for null values, throwing `ArgumentNullException` when necessary.
- Ensure that deserialization logic handles the correct casing for node type names. The serializer uses capitalized names (e.g., `FunctionDeclaration`), so the deserializer should be updated to match.
- Always validate parameters for null values and throw `ArgumentNullException` when null.
- When constructing `ReturnStatement` objects in the TUI, always pass `AstLeafNode<string>` objects instead of raw strings to ensure type consistency within the AST.
- Follow code style rules and resolve warnings, including:
    - IDE0008: Use explicit type instead of 'var' where applicable.
    - CA1720: Avoid type names in identifiers (e.g., avoid "String" in `Literal.String`).
    - CA1830: Use strongly-typed StringBuilder overload.
    - CA1854: Prefer TryGetValue over ContainsKey check for dictionaries.
    - CA1834: Use StringBuilder.Append(char) for constant unit strings.
    - CA1862: Prefer string.Equals(string, StringComparison) for case-insensitive comparisons.
    - CA1062: Validate non-null parameters in externally visible methods.
    - CA1822: Mark members that do not access instance data as static.
    - CS0029: Avoid implicit type conversions that can lead to errors.
    - CS1061: Ensure objects have the DeepClone definition when calling DeepClone.
    - IDE0021: Use expression body for constructor.

## DEBUGGING

- Use the debugger to step through code and inspect variables.
- Write unit tests to isolate and fix bugs.
- Use logging to track the flow of execution and identify issues.
- Address code analysis warnings and errors identified during build processes (e.g., CS8852, IDE2003, CA1502, IDE0010) by refactoring code or modifying code as needed. Specifically:
    - **CS8852**: Ensure init-only properties are only assigned during object initialization, in the constructor, or in an `init` accessor.
    - **IDE2003**: Enforce blank lines between blocks and subsequent statements.
    - **CA1502**: Refactor methods with high cyclomatic complexity into smaller, more manageable methods.
    - **IDE0010**: Populate switch statements with all possible enum values or provide a default case.
- Analyze and fix compilation errors reported by the .NET build process.
- When adding rows to a table, ensure that values are not null before passing them to the `AddRow` method to avoid `CS8604` errors. Use the null-coalescing operator (`??`) to provide default values if necessary.

## WORKFLOW & RELEASE RULES

- Create a new branch for each feature or bug fix.
- Submit a pull request for review before merging into the main branch.
- All pull requests must pass unit tests and code review.
- Use semantic versioning for releases.

## AST RULES

- The AST should be language-agnostic.
- AST nodes should be serializable and deserializable.
- Implement a `Clone()` method for all AST nodes to enable deep copying.
- The `Metadata` property in `AstNode` and derived classes should have a `protected init` setter to allow setting during object initialization in derived classes and prevent modification after initialization. When cloning `Metadata`, clear the existing dictionary and copy the values from the original instead of assigning a new dictionary.
- Ensure that deserialization logic respects the `protected init` setter of the `Metadata` property in `AstNode` and derived classes. Refactor deserialization logic if necessary to correctly initialize this property.
- When cloning `Metadata`, clear the existing dictionary and copy the values from the original instead of assigning a new dictionary.
- **Always construct `ReturnStatement` objects using `AstLeafNode<string>` objects instead of raw strings to maintain type consistency within the AST.**
- The project will use a simplified approach to AST extensions: Add VariableDeclaration/AssignmentStatement but use the existing AstLeafNode approach for expressions.
- For variable assignments, the following approach should be used:
```csharp
// Keep it simple but still structured
var assignment = new AssignmentStatement("result", "a + b");
var declaration = new VariableDeclaration("int", "count", "0");
```

## DEPENDENCY INJECTION RULES

- Use `ServiceCollectionExtensions` to register language generators and serialization services.
- Always use `ArgumentNullException.ThrowIfNull(services)` at the beginning of each extension method to validate the service collection.
- All Coder services should be registered as singletons within the dependency injection container.